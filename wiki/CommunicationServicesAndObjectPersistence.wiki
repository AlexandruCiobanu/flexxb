#summary Overview of the basic XML communication service and object persistence support available in FlexXB
#labels Phase-Implementation

= Introduction =

Besides the powerful xml processing capabilities, FlexXB also offers support for communicating with the server as well as the notion of persistable objects.

== Server communication ==

Having the ability to convert ActionScript objects to xml and vice versa is quite redundant if not for a means of communicating with the back end server consuming and producing the xml request and responses.
FlexXB offers server communication capabilities by the classes located in {{{com.googlecode.flex.service}}}. They are enumerated below along with a short description of their purpose:

 * {{{ITranslator}}} - Interface for defining a translator. Translators take care of creating the request objects, serialize them into a xml request, deserialize the xml response into a response object and retrieving the actual useful data from it.
 * {{{ICommunicator}}} - Interface for defining a communicator. It is basically a wrapper for the object that sends requests to the server in the protocol and format required and receives responses from it.
 * {{{Communicator}}} - Default implementation of ICommunicator. Allows sending/receiving xml via HTTP.
 * {{{AbstractService}}} - This is the base for all service classes. Uses an instance of an ICommunicator implemetor to send requests and retrieve responses.
 * {{{ServiceSettings}}} - Settings object for configuring the service. Contains several built-in variables covering the must-have settings like url, HTTP method etc.

If one can understand the need for the {{{AbstractService}}} or {{{ServiceSettings}}}, there are here two notions that might elude him/her: translators and communicators.

=== 1. Translators ===

When communicating with a server, besides the useful data, there is a sometimes significant amount of "protocol overhead". For example, connecting to a server requires a login and then the use of a session identifier. When sending a request to create an object you must format it in a specific manner, adding the session identifier to allow for the server's authentication process. Also, when receiving a response, it may come with additional data to it in the form of a wrapper around the useful response data, containing the exact date and time the response was processed, the status of the operation (executed successfully or threw an error) etc. 

All this apparent overhead represents the communication protocol with the server. It means that the xml received/sent has a specific format and must include some information besides of the data solely related with the operation being invoked (insert, update, delete etc). This protocol data doesn't need to be offered outside the service layer. It is related strictly with the communication with the server.

This is where the translators come in. They conceal the complexity of using the protocol objects by building the request in a form accepted by the server from application data and providing data that can be processed by the application from the server response. In this process they also take care of the AS3 - XML conversion specific to each communication stage (SEND, RECEIVE). You can see them as adapters.

Let's take a quick look at the ITranslator definition:

{{{
public interface ITranslator         
{                 
	/**
	* Create the XML request to be sent to the server                  
	* @return XML request                  
	*                   
	*/                              
	function createRequest() : XML;                 
	/**                  
	* Get the response xml from the server and convert it to the response object.                  
	* @param data xml response                  
	* @return actual response object                  
	*                   
	*/                              
	function parseResponse(data : XML) : Object;
	/**                  
	*                   
	* @param response the response received from the server.                  
	* @return the object the represents the response.                  
	*/                 
	function extractResponseData(response : Object) : Object;         
} 
}}}

The first method, {{{createRequest}}}, is responsible for building the actual XML to be sent to the server. There are two ways of building the request, basically: build the XML directly by simply writing it in the method's body or build the XML by creating the request object and then using the serializer to extract the xml request.

{{{parseResponse}}} is designed for performing the deserialization from the received xml to AS objects. Basically, the resulting object is a representation of the entire response, containing all protocol overhead. At this point you can run different checks, for the validity of the response for example. After checkups pass, you can extract the usefull data from the response object, which is the purpose of the {{{extractResponseData}}} method.

=== 2. Communicators ===

TODO

== Persistence ==

TODO