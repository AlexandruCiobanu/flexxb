#summary List of explained features
#labels Phase-Support,Phase-Implementation

TODO
==Xml alias==

     _Each object or object field can be rendered as xml under a name which can be different from it's regular name (alias)._

Alias attribute is available for all field annotations and allows the engine to render the value as an attribute/element with a different name that the field's name. If the alias attributes is missing the engine will use the field's name as a name for the xml sequence to be inserted/parsed.

Eg:
{{{
        [Bindable]
	public class Mock
	{
		[XmlAttribute()]
		public var date : Date;

                [XmlAttribute(alias="stuff")]
		public var aField : String = "a";

		[XmlElement(alias="objVersion")]
		public var version : Number = 4;

		[XmlArray(alias="data", type="com.googlecode.testData.Mock")]
		public var result : Array;
		[XmlElement]
		public var xmlData : XML; 
		
		public var someExcludedField  : Boolean;
	}
}}}


<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>

==Support for object namespacing==

     _Xml requests and responses can have namespaces for each composing element, thus each model object must be liked to its corresponding namespace._

There are two ways namespaces can be defined on the metadata used to decorate a class:
 * Class namespace - defined in the [XmlAnnotations#XmlClass XmlClass] annotation and it is the default namespace used for all fields in the class. Spcifying it is done by setting the {{{prefix}}} and {{{uri}}} attributes of the [XmlAnnotations#XmlClass XmlClass] annotation.
 * Field namespace - is used by specific fields within the class; multiple fields can reference the same namespace. Field namespaces are defined by first declaring them at class level with [XmlAnnotations#Namespace Namespace] annotation then referencing its prefix where needed. Field namespaces' prefixes should be unique for that class. 

Eg:
{{{
        [Bindable]
        [Namespace(prefix="ns1", uri="http://www.ns1.com")]
        [Namespace(prefix="ns2", uri="http://www.ns2.com")]
	[XmlClass(alias="MyClass", prefix="test", uri="http://www.yourcompany.com/xmlns/yourNs")]
	public class Mock
	{
		[XmlAttribute(namespace="ns1")]
		public var date : Date;

                [XmlAttribute(alias="stuff")]
		public var aField : String = "a";

		[XmlElement(alias="objVersion")]
		public var version : Number = 4;

		[XmlArray(alias="data", type="com.googlecode.testData.Mock", namespace="ns2")]
		public var result : Array;
		[XmlElement]
		public var xmlData : XML; 
		
		public var someExcludedField  : Boolean;
	}
}}}
 
<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


==Ignore a field on serialization, deserialization or both==
 
     _An object's field can be disregarded completly from the (de)serialization process or skipped on serialization or deserialization._

Fields can be excluded from the (de)serialization process by setting the {{{ignoreOn}}} in all field annotations. There are two possible values:
 * serialize: ignore the value of the current field when serializing the object;
 * deserialize: ignore the value of the current field when deserializing the data (xml);

In order to have the field completely ignored remove the field annotation on it. FlexXB will only process fields that have a recognized annotation decorating them.

Eg:
{{{
        [Bindable]
	[XmlClass(alias="MyClass", prefix="test", uri="http://www.yourcompany.com/xmlns/yourNs")]
	public class Mock
	{
		[XmlAttribute(alias="stuff")]
		public var aField : String = "a";
		
                [XmlAttribute(ignoreOn="serialize")]
		public var date : Date;
		
                [XmlElement(alias="objVersion")]
		public var version : Number = 4;
		
		[XmlElement(ingnoreOn="deserialize")]
		public var reference : Object;
				
                [XmlElement]
		public var xmlData : XML; 
		
		public var someExcludedField  : Boolean;
	}
}}}

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


== Serialize partial object== 

     _An object's field can be serialized as a partial rendering (an element having as name the field's alias and subelement or attribute its id)._

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


==Integrate model object cache to insure object uniqueness==
 
     _All deserialized objects received as responses should be cached according to their type and unique id in order to preserve object uniqueness across the application._

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


== Class type identification by response's namespace on deserialization==

     _Object types that should be used in deserialization should be determined from the namespaces present in the xml response._

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


== Custom to and from string conversion for simple types==  

     _Some simple types (such as Date) may require custom conversion methods to and from String values._

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


== Use paths in xml aliases== 

     _Some fields in an object can be renderer as being eveloped in an hierarchy of elements that do not have actionScript correspondents (basically, the model objects will shortcircuit a part of the server object's hierarchy)._

Also known as *virtual paths*, this feature allows classes to have fields rendered in subelements withour requiring existence of special classes for those subelements. Virtual paths are defined within the alias attribute on each annotation: {{{XmlClass}}}, {{{XmlAttribute}}}

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


== Allow custom object (de)serialization==  

     _There are specific cases in which a user defined serialization/deserialization process and objects needing such a process should notify FlexXB of that intent._

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


== Add getFromCache option for deserializing complex fields== 

     _Fields marked with getFromCache option will be extracted from cache or, if the object is absent from cache, will be deserialized._

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


== Add events to signal processing start and finish==

     _The serializer should allow custom treatments at different stages in the xml processing. These stages are: _Pre-Serialize_, _Post-Serialize_, _Pre-Deserialize_ and _Post-Deserialize_._

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


== Xml Service ==

     _FlexXB should provide a data service that is able to send xml requests and receive xml responses._

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


== Annotation API ==

     _FlexXB should provide an API to allow developers to programatically describe object types to be registered in the FlexXB engine._

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


== Constructor Annotation==

     _There are cases in which the business objects have parametered constructors which should not default to null in order to inforce some business constraints. FlexXB should provide a way to annotate the constructors along with the parameers they take. Due to the fact that those parameters will more than likely have values found in the xml (like serialized object fields) the parameters will reference a field that will be the end-receiver of the value._ 

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


== Multiple namespace support==

     _Allow multiple namespaces to be defined for a class. Various members of the class can use different namespaces._

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


== Annotation versioning ==

     _Allow multiple annotations per field differentiated by a version. This is extremely useful when the same object can be rendered to xml in different ways accorduing to the end server it is talking to._

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>

== Circular reference handling ==

     _This feature is the same as offered by JAXB: https://jaxb.dev.java.net/guide/Mapping_cyclic_references_to_XML.html. When encountering objects cycles, the application needs to recover from it without ending up in a stack overflow exception. To do this you will be able to specify objects once in the xml document and reference them by id wherever is needed; also one may implement a custom interface allowing the replacement of the current object with a new one that will break the cycle._

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>


== Serialization format support==
 
     _Make FlexXB serialization format agnostic. Allows users to extend the engine and add support for different serialization formats (JSON, etc) while still sharing the base features such as object caching, circular reference handling, constructor annotations, id fields, version extraction. The advantage is that the base features are integrated by default with the new serialization context that defines the new format and one should only care about the actual AS3 object - ? conversions._

<table width="100%">
   <tr>
     <td align="left">[Features Back to Features]</td>
     <td align="right">[FeaturesExplained Top]</td>
   </tr>
</table>