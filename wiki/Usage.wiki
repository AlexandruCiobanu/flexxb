#summary FlexXB usage
#labels Featured
= Using the FlexXB library =

To serialize an object to xml:<br/>
{{{com.googlecode.serializer.flexxb.FlexXBEngine.serialize(object)}}}

To deserialize a received xml to an object, given the object's class:<br/>
{{{com.googlecode.serializer.flexxb.FlexXBEngine.deserialize(xml, class)}}}

To register a custom annotation, subclass of {{{com.googlecode.serializer.flexxb.Annotation}}}:<br/>
{{{com.googlecode.serializer.flexxb.FlexXBEngine.registerAnnotation(name, annotationClass, serializerClass, overrideExisting)}}}

To register a converter that will handle how an object of a specific type is converted to a String value that will be attached to the xml representation and viceversa:<br/>
{{{com.googlecode.serializer.flexxb.FlexXBEngine.registerSimpleTypeConverter(converterInstance, overrideExisting)}}}

*Note*: Make sure you add the following switches to your compiler settings: {{{-keep-as3-metadata XmlClass -keep-as3-metadata XmlAttribute -keep-as3-metadata XmlElement -keep-as3-metadata XmlArray}}}

= Annotating model classes =

There are four annotations defined:

 XmlClass {{{[XmlClass(alias="MyClass", useNamespaceFrom="elementFieldName", idField="idFieldName", prefix="my", uri="http://www.your.site.com/schema/", defaultValueField="fieldName", ordered="true|false")] }}}

 XmlAttribute {{{[XmlAttribute(alias="attribute", ignoreOn="serialize|deserialize", order="orderIndex")]}}}

 XmlElement {{{[XmlElement(alias="element", getFromCache="true|false", ignoreOn="serialize|deserialize", serializePartialElement="true|false", order="orderIndex")]}}} 

 XmlArray {{{[XmlArray(alias="element", memberName="NameOfArrayElement", getFromCache="true|false", type="my.full.type" ignoreOn="serialize|deserialize", serializePartialElement="true|false", order="orderIndex")]}}}

*Note*: Using as alias "{{{*}}}" on a field will force the serializer to serialize that 
field using an alias computed at runtime by the runtime type of the field's value, except for XmlArray.
For XmlArray using the "{{{*}}}" alias will cause the members of the array value to be rendered as children of the owner object xml rather than children of an xml element specifying the array.

== Annotation samples ==

=== 1. Basic sample using xml annotations ===

_This is a simple example on using xml annotations. Only fields that have been decorated with an annotation will be taken into account in the (de)serialization process. Notice the idField attribute. It specifies that this object supports a compact method of defining it in xml, by only specifying the id. The id will be rendered as element or attribute in the owner xml. _

{{{
        [XmlClass(alias="MOck2Replacement", idField="id")]
	public class Mock3
	{
		[XmlAttribute]
		public var id : Number = 3;
		[XmlAttribute]
		public var attribute : Boolean;
		[XmlElement(alias="objectVersion")]
		public var version : Number;
		
		public function Mock3()
		{
			super();
		}
	}
}}}

_The object has been built as:_

{{{
        var target : Mock3 = new Mock3();
	target.attribute = true;
	target.id = 5;
	target.version = 33;
}}}

_The resulting XML is:_

{{{
<MOck2Replacement attribute="true" id="5">
  <objectVersion>
    33
  </objectVersion>
</MOck2Replacement>
}}}

=== 2. Namespacing objects ===

_The object defines its own namespace under which it is serialized. Notice the serializePartialElement attribute in the XmlElement annotations. It specifies that the value will be serialized in a compact manner, that is, by only specifying the id of an object. For this, the object must have defined an id field as seen in the first sample_

{{{
        [Bindable]
	[XmlClass(alias="MyClass", prefix="test", uri="http://www.axway.com/xmlns/passport/v1")]
	public class Mock
	{
		[XmlAttribute(alias="stuff")]
		public var aField : String = "a";
		[XmlAttribute(ignoreOn="serialize")]
		public var date : Date;
		[XmlElement(alias="objVersion")]
		public var version : Number = 4;
		[XmlElement(alias="mock3", serializePartialElement="true")]
		public var link : Mock3;
		[XmlElement(serializePartialElement="true")]
		public var reference : Object;
		[XmlArray(alias="data", type="com.googlecode.testData.Mock")]
		public var result : Array;
		[XmlElement]
		public var xmlData : XML; 
		
		public var someExcludedField  : Boolean;
		
		public function Mock(){
			//TODO: implement function
		}
	}
}}}

_The object to be serialized has been built as_

{{{
        var target : Mock = new Mock();
	target.link = new Mock3();
	target.aField = "test1";
	target.date = new Date();
	target.version = 6;
	target.result = [];
	var mk : Mock = new Mock();
	mk.date = new Date();
	mk.aField = "mocktestfield";
	target.result.push(mk);
	target.xmlData = <test id="1"><element>retw</element></test>
}}}

_The resulting XML is:_

{{{
<test:MyClass test:stuff="test1" xmlns:test="http://www.axway.com/xmlns/passport/v1">
  <test:data>
    <test:MyClass test:stuff="mocktestfield">
      <test:objVersion>
        4
      </test:objVersion>
    </test:MyClass>
  </test:data>
  <test:objVersion>
    6
  </test:objVersion>
  <test:xmlData>
    <test id="1">
      <element>
        retw
      </element>
    </test>
  </test:xmlData>
  <test:mock3 id="3"/>
</test:MyClass>
}}}

=== 3. Using virtual paths ===

_A member's alias can define "virtual paths". Virtual paths allow definition of complex xml structures for a field without complicating the model design. Thus, structures can be present in the xml just by adding virtual paths in the alias definition of a member.

Let's assume the xml representation looks like:_

{{{
<myPathTester>
  <anotherSub attTest="Thu Mar 19 15:49:32 GMT+0200 2009"/>
  This is Default!!!
  <subObject>
    <id>
      2
    </id>
    <subSubObj>
      <ref>
        ReferenceTo
      </ref>
    </subSubObj>
  </subObject>
</myPathTester>
}}}

_This would normally translate itself in about 4 model classes. Using virtual paths, one can describe it in just one model class:_

{{{
[XmlClass(alias="myPathTester", defaultValueField="defaultTest")]
public class XmlPathObject
{
	[XmlElement(alias="subObject/id")]
	public var identity : Number = 2;
	[XmlElement(alias="subObject/subSubObj/ref")]
	public var reference : String = "ReferenceTo"; 
	[XmlArray(alias="subObject/list")]
	public var list : Array;
	[XmlAttribute(alias="anotherSub/attTest")]
	public var test : Date = new Date();
	[XmlElement()]
	public var defaultTest : String = "This is Default!!!"
	
	public function XmlPathObject()
	{
	}
}
}}}

_Notice the {{{defaultValueField}}} attribute. It specifies that the target field will be rendered in xml as a simple text element. Still, the field maked as default will still have to be decorated by an annotation to be taken into account by the serializer._

=== 4. Ordering the xml sequence ===

_FlexXB supports ordering the fields of an object in the rendered xml either by order index or by field alias both defined in the annotation decorating the field. For ordering to be activated, the ordered attribute must be set to true._

{{{
	[XmlClass(name="OrderTest", ordered="true")]
	public class Persist extends PersistableObject
	{
		[XmlElement(order="1")]
		public var isOK : Boolean = false;
		[XmlElement(order="3")]
		public var test1 : int;
		[XmlElement(order="2")]
		public var test2 : String;		
		
		public function Persist(){
			super();
		}		
	}
}}}

_The resulting xml looks like:_

{{{
<Persist>
  <isOK>
    false
  </isOK>
  <test2>
    valoare
  </test2>
  <test1>
    3
  </test1>
</Persist>
}}}