#summary FlexXB usage
#labels Featured
= Using the FlexXB library =

To serialize an object to xml:<br/>
{{{com.googlecode.serializer.flexxb.FlexXBEngine.serialize(object)}}}

To deserialize a received xml to an object, given the object's class:<br/>
{{{com.googlecode.serializer.flexxb.FlexXBEngine.deserialize(xml, class)}}}

To register a custom annotation, subclass of {{{com.googlecode.serializer.flexxb.Annotation}}}:<br/>
{{{com.googlecode.serializer.flexxb.FlexXBEngine.registerAnnotation(name, annotationClass, serializerClass, overrideExisting)}}}

To register a converter that will handle how an object of a specific type is converted to a String value that will be attached to the xml representation and viceversa:<br/>
{{{com.googlecode.serializer.flexxb.FlexXBEngine.registerSimpleTypeConverter(converterInstance, overrideExisting)}}}

To enable/diable object caching:
{{{
//disable
com.googlecode.serializer.flexxb.FlexXBEngine.configuration.cacheProvider = null;
//enable
com.googlecode.serializer.flexxb.FlexXBEngine.configuration.cacheProvider = new com.googlecode.flexxb.cache.ObjectCache();
   //or
com.googlecode.serializer.flexxb.FlexXBEngine.configuration.cacheProvider = new com.googlecode.flexxb.cache.ObjectPool();
}}}

In order to register a class descriptor created via the FlexXB API for classes that cannot be accessed in order to add annotations:
{{{com.googlecode.serializer.flexxb.FlexXBEngine.instance.api.processTypeDescriptor(apiTypeDescriptor)}}}

To provide an API descriptor file content in which the class descriptors are depicted in an XML format:<br/>
{{{com.googlecode.serializer.flexxb.FlexXBEngine.instance.api.processDescriptorsFromXml(xml)}}}

*Note*: Make sure you add the following switches to your compiler settings: {{{-keep-as3-metadata XmlClass -keep-as3-metadata XmlAttribute -keep-as3-metadata XmlElement -keep-as3-metadata XmlArray -keep-as3-metadata ConstructorArg}}}

= Annotating model classes =

There are four annotations defined:

 XmlClass {{{[XmlClass(alias="MyClass", useNamespaceFrom="elementFieldName", idField="idFieldName", prefix="my", uri="http://www.your.site.com/schema/", defaultValueField="fieldName", ordered="true|false", version="versionValue")] }}}

 XmlAttribute {{{[XmlAttribute(alias="attribute", ignoreOn="serialize|deserialize", order="orderIndex", version="versionValue")]}}}

 XmlElement {{{[XmlElement(alias="element", getFromCache="true|false", ignoreOn="serialize|deserialize", serializePartialElement="true|false", order="orderIndex", version="versionValue")]}}} 

 XmlArray {{{[XmlArray(alias="element", memberName="NameOfArrayElement", getFromCache="true|false", type="my.full.type" ignoreOn="serialize|deserialize", serializePartialElement="true|false", order="orderIndex", version="versionValue")]}}}

*Note*: Using as alias "{{{*}}}" on a field will force the serializer to serialize that 
field using an alias computed at runtime by the runtime type of the field's value, except for XmlArray.
For XmlArray using the "{{{*}}}" alias will cause the members of the array value to be rendered as children of the owner object xml rather than children of an xml element specifying the array.

= Extending FlexXB =

FlexXB offers several extension points:
 * Create a custom serializer
 * Create a custom annotation along with its own serializer
 * Implement specialised interfaces in your model objects to modify the engine's behavior on serialization/deserialization.

== Creating custom annotations ==

Annotation structure has changed as of FlexXB 1.7.0 to reflect a global movement whose intent is to make the engine serialization format agnostic (being able to serialize/deserialize Xml, JSON, etc). It has been split into three parts: the contract, the annotation parser and the annotation implementations. 

*The contract* specifies the accepted structure and relationships between annotation as well as a standardization of the types available. Thus we differentiate between three types of annotations:
 * Class annotations ({{{com.googlecode.flexxb.annotation.contract.IClassAnnotation}}})
They are defined at class level and establish conventions for rendering/parsing the wrapper or shell without populating the fields. Class annotations hold references to the list of member annotations defined as well as information about the constructor structure (see Constructor and ConstructorArgument classes). Generally, class instances are identified by an id field and the class annotation can keep a reference to the member metadata annotating the field, in order to know how to render/parse it. Ids are generally used in combination with object caching.
 * Global annotations ({{{com.googlecode.flexxb.annotation.contract.IGlobalAnnotation}}})
They are also defined at class level but do not have direct consequences in the rendering/parsing process. Global annotations are used for specifying configuration elements that the class or member annotation can use (for example, mapping the constructor arguments to class fields, specifying the namespaces used in the class etc.). The contract specifies the constructor argument metadata as a part of class metadata mapping.
 * Member annotations ({{{com.googlecode.flexxb.annotation.contract.IMemberAnnotation}}})
They are defined at field level and establish the conventions for rendering/parsing the field they annotate (for example, whether the field is rendered as ann attribute or an element, its alias etc.). 

== Creating custom serializers ==

To create a custom serializer one should implement the {{{com.googlecode.flexxb.serializer.ISerializer}}} interface. Thus one can provide the logic for serializing objects into xml and deserializing xml into actionScript objects. 
After creating your serializer you must register it with the FlexXB engine.
Below you can see the structure of the ISerializer interface, with its two methods, one for serialization, the other for deserialization.
{{{
package com.googlecode.flexxb.serializer {
          import com.googlecode.flexxb.SerializerCore;
          import com.googlecode.flexxb.annotation.contract.IAnnotation;
          /**
           * Interface for an annotation bound xml serializer.
           * @author aCiobanu
           *
           */
          public interface ISerializer {
                  /**
                   * Serialize an object into xml
                   * @param object Object to be serialized
                   * @param annotation Annotation containing the conversion parameters
                   * @param parentXml Parent xml that will enclose the objects xml representation
                   * @serializer
                   * @return Generated xml
                   *
                   */
                  function serialize(object : Object, annotation : IAnnotation, parentXml : XML, serializer : SerializerCore) : XML;
                  /**
                   * Deserialize an xml into the appropiate AS3 object
                   * @param xmlData Xml to be deserialized
                   * @param annotation Annotation containing the conversion parameters
                   * @serializer
                   * @return Generated object
                   *
                   */
                  function deserialize(xmlData : XML, annotation : IAnnotation, serializer : SerializerCore) : Object;
          }
}  
}}}

You can also extend existing serializers and provide additional features to them. A good starting place is {{{com.googlecode.flexxb.serializer.MemberSerializer}}}, the base for `AttributeSerializer`, `ElementSerializer`, `ArraySerializer`. You may override the regular public methods defined by ISerializer or the two protected methods, inorder to still benefit from the features `MemberSerializer` brings (such as virtual paths): 
{{{
protected function serializeObject(object : Object, annotation : XmlMember, parentXml : XML, serializer : SerializerCore) : void
protected function deserializeObject(xmlData : XML, xmlName : QName, annotation : XmlMember, serializer : SerializerCore) : Object;  
}}}

== Model object interfaces ==

There are four main interfaces objects can implement in order to impose a specific behavior of the engine: IXmlSerializable, ISerializeNotifiable, IDeserializeNotifiable and ICycleRecoverable. All these interfaces are located in the com.googlecode.flexxb.interfaces.

=== 1. {{{com.googlecode.flexxb.interfaces.IXmlSerializable}}} ===

You use this interface if your object requires teh serialization/deserialization process be handled in a customized manner. This way the object itself will handle its own parsing/rendering.

{{{
/**           
* Interface for an object that requires custom serialization/deserialization into/from Xml
* @author aciobanu
*
*
*/          
public interface IXmlSerializable extends IIdentifiable {
{
         /**          
          * Serialize current object into Xml        
          */     
          function toXml() : XML;     
         /**          
          * Deserialize this object from one of it's possible XML representation.         
          * @param xmlData xml data source       
          */        
          function fromXml(xmlData : XML) : Object;       
         /**     
          *        
          * @param xmldata        
          * @return          
          *         
          */        
          function getIdValue(xmldata : XML) : String;
}  
}}}
The {{{getIdValue}}} method is used in case your object is identifiable by an id, and allows the extraction of the id value that is used in case you have object caching enabled. With the obtained id, the engine can look into the cache for an instance associated to that id and get that instance instead of creating a new object.

=== 2. {{{com.googlecode.flexxb.interfaces.ISerializeNotifiable}}} ===

Implementing this interfaces allows the object to get notified of the stages in which teh serialization process is: Pre-serialize and post-serialize. The FlexXB Engine's default behavior is to dispatch pre/post serialize events as they occur for each object processed. When it encounters an ISerializeNotifiable object, it will call its {{{onPreSerialize}}} and {{{onPostSerialize}}} methods, overriding the default behavior.

{{{
/**
 * Optional interface to be implemented by objects which need specific
 * notification on the serialization process.<br> 
 * If the current object to be serialized implements this interface, the
 * engine will call the methods implemented on each process step (pre and 
 * post serialize) instead of firing an XmlEvent on the engine instance for
 * each step. <br>
 * Implementing this interface overrides the normal event dispatching in the 
 * engine.   
 * @author Alexutz
 * 
 */	
public interface ISerializeNotifiable
{
	/**
	 * Called before the serialization process of the current object begins.
	 * @param parent
	 * @param xmlData
	 * 
	 */				
	function onPreSerialize(parent : Object, xmlData : XML) : void;
	/**
	 * Called after the serialization process of the current object ends.
	 * @param parent
	 * @param xmlData
	 *  
	 */		
	function onPostSerialize(parent : Object, xmlData : XML) : void;
}
}}}

=== 3. {{{com.googlecode.flexxb.interfaces.IDeserializeNotifiable }}} ===

Implementing this interfaces allows the object to get notified of the stages in which teh deserialization process is: Pre-deserialize and post-deserialize. The FlexXB Engine's default behavior is to dispatch pre/post deserialize events as they occur for each object processed. When it encounters an IDeserializeNotifiable object, it will call its {{{onPreDeserialize}}} and {{{onPostDeserialize}}} methods, overriding the default behavior.
{{{
/**
 * Optional interface to be implemented by objects which need specific
 * notification on the deserialization process.<br> 
 * If the current object to be serialized implements this interface, the
 * engine will call the methods implemented on each process step (pre and 
 * post deserialize) instead of firing an XmlEvent on the engine instance for
 * each step. <br>
 * Implementing this interface overrides the normal event dispatching in the 
 * engine.   
 * @author Alexutz
 * 
 */	
public interface IDeserializeNotifiable
{
	/**
	 * Called before the deserialization process of the current object begins.
	 * @param parent
	 * @param xmlData
	 * 
	 */		
	function onPreDeserialize(parent : Object, xmlData : XML) : void;
	/**
	 * Called after the deserialization process of the current object ends.
	 * @param parent
	 * @param xmlData
	 * 
	 */	
	function onPostDeserialize(parent : Object, xmlData : XML) : void;
}
}}}

=== 4. {{{com.googlecode.flexxb.interfaces.ICycleRecoverable}}} ===

FlexXB is able to detect and handle object cycles that would otherwise make it go into an infinite loop. One can implement this interface to instruct the engine to turn to the current object causing teh cycle and ask it to provide a replacement for itself, one that would break the cycle.
{{{
/**
 * Optional interface that can be implemented by FlexXB bound objects to handle 
 * cycles in the object graph.
 * <p/>Normally a cycle in the object graph causes the engine to throw an error.
 * This is not always a desired behavior.Implementing this interface allows the 
 * user application to change this behavior.
 * 
 * @author Alexutz
 * 
 */	
public interface ICycleRecoverable
{
	/**
	 * Called when a cycle is detected by the engine to nominate a new
	 * object to be serialized instead.
	 * @param parentCaller reference to the parent object referencing the current ne 
	 * @return the object to be serialized instead of <code>this</code> or null to 
	 * instruct the engine to behave as if the object does not implement this interface. 
	 * 
	 */			
	function onCycleDetected(parentCaller : Object) : Object;
}
}}}


= Samples =

== Annotation samples ==

=== 1. Basic sample using xml annotations ===

_This is a simple example on using xml annotations. Only fields that have been decorated with an annotation will be taken into account in the (de)serialization process. Notice the idField attribute. It specifies that this object supports a compact method of defining it in xml, by only specifying the id. The id will be rendered as element or attribute in the owner xml. _

{{{
        [XmlClass(alias="MOck2Replacement", idField="id")]
	public class Mock3
	{
		[XmlAttribute]
		public var id : Number = 3;
		[XmlAttribute]
		public var attribute : Boolean;
		[XmlElement(alias="objectVersion")]
		public var version : Number;
		
		public function Mock3()
		{
			super();
		}
	}
}}}

_The object has been built as:_

{{{
        var target : Mock3 = new Mock3();
	target.attribute = true;
	target.id = 5;
	target.version = 33;
}}}

_The resulting XML is:_

{{{
<MOck2Replacement attribute="true" id="5">
  <objectVersion>
    33
  </objectVersion>
</MOck2Replacement>
}}}

=== 2. Namespacing objects ===

_The object defines its own namespace under which it is serialized. Notice the serializePartialElement attribute in the XmlElement annotations. It specifies that the value will be serialized in a compact manner, that is, by only specifying the id of an object. For this, the object must have defined an id field as seen in the first sample_

{{{
        [Bindable]
	[XmlClass(alias="MyClass", prefix="test", uri="http://www.yourcompany.com/xmlns/yourNs")]
	public class Mock
	{
		[XmlAttribute(alias="stuff")]
		public var aField : String = "a";
		[XmlAttribute(ignoreOn="serialize")]
		public var date : Date;
		[XmlElement(alias="objVersion")]
		public var version : Number = 4;
		[XmlElement(alias="mock3", serializePartialElement="true")]
		public var link : Mock3;
		[XmlElement(serializePartialElement="true")]
		public var reference : Object;
		[XmlArray(alias="data", type="com.googlecode.testData.Mock")]
		public var result : Array;
		[XmlElement]
		public var xmlData : XML; 
		
		public var someExcludedField  : Boolean;
		
		public function Mock(){
			//TODO: implement function
		}
	}
}}}

_The object to be serialized has been built as_

{{{
        var target : Mock = new Mock();
	target.link = new Mock3();
	target.aField = "test1";
	target.date = new Date();
	target.version = 6;
	target.result = [];
	var mk : Mock = new Mock();
	mk.date = new Date();
	mk.aField = "mocktestfield";
	target.result.push(mk);
	target.xmlData = <test id="1"><element>retw</element></test>
}}}

_The resulting XML is:_

{{{
<test:MyClass test:stuff="test1" xmlns:test="http://www.yourcompany.com/xmlns/yourNs">
  <test:data>
    <test:MyClass test:stuff="mocktestfield">
      <test:objVersion>
        4
      </test:objVersion>
    </test:MyClass>
  </test:data>
  <test:objVersion>
    6
  </test:objVersion>
  <test:xmlData>
    <test id="1">
      <element>
        retw
      </element>
    </test>
  </test:xmlData>
  <test:mock3 id="3"/>
</test:MyClass>
}}}

=== 3. Using virtual paths ===

_A member's alias can define "virtual paths". Virtual paths allow definition of complex xml structures for a field without complicating the model design. Thus, structures can be present in the xml just by adding virtual paths in the alias definition of a member.

Let's assume the xml representation looks like:_

{{{
<myPathTester>
  <anotherSub attTest="Thu Mar 19 15:49:32 GMT+0200 2009"/>
  This is Default!!!
  <subObject>
    <id>
      2
    </id>
    <subSubObj>
      <ref>
        ReferenceTo
      </ref>
    </subSubObj>
  </subObject>
</myPathTester>
}}}

_This would normally translate itself in about 4 model classes. Using virtual paths, one can describe it in just one model class:_

{{{
[XmlClass(alias="myPathTester", defaultValueField="defaultTest")]
public class XmlPathObject
{
	[XmlElement(alias="subObject/id")]
	public var identity : Number = 2;
	[XmlElement(alias="subObject/subSubObj/ref")]
	public var reference : String = "ReferenceTo"; 
	[XmlArray(alias="subObject/list")]
	public var list : Array;
	[XmlAttribute(alias="anotherSub/attTest")]
	public var test : Date = new Date();
	[XmlElement()]
	public var defaultTest : String = "This is Default!!!"
	
	public function XmlPathObject()
	{
	}
}
}}}

_Notice the {{{defaultValueField}}} attribute. It specifies that the target field will be rendered in xml as a simple text element. Still, the field maked as default will still have to be decorated by an annotation to be taken into account by the serializer._

=== 4. Ordering the xml sequence ===

_FlexXB supports ordering the fields of an object in the rendered xml either by order index or by field alias both defined in the annotation decorating the field. For ordering to be activated, the ordered attribute must be set to true._

{{{
	[XmlClass(name="OrderTest", ordered="true")]
	public class Persist extends PersistableObject
	{
		[XmlElement(order="1")]
		public var isOK : Boolean = false;
		[XmlElement(order="3")]
		public var test1 : int;
		[XmlElement(order="2")]
		public var test2 : String;		
		
		public function Persist(){
			super();
		}		
	}
}}}

_The resulting xml looks like:_

{{{
<Persist>
  <isOK>
    false
  </isOK>
  <test2>
    valoare
  </test2>
  <test1>
    3
  </test1>
</Persist>
}}}

== API Samples ==

The FlexXB API allows developers to specify the way classes should be processed without decorating them with annotations. This is particularly usefull is cases when using an external library whose sources are not available or when you can't modify existing sources for one reason or another. There are two ways of using the API:
  
 * Programatically: you can define in code the fields of a specific type that can be processed and how.
 * Via xml config file: you can define an xml file containing all the information FlexXB engine needs to process the specified types. This file must oblige to the api schema file located in _*FLEXXB_BINARIES_DIR/api-schema/FlexXB-api.xsd*_.
The main access point for the api is {{{com.googlecode.serializer.flexxb.FlexXBEngine.instance.api}}}.

=== 1. Programatically building descriptor ===

Let's assume we have the following object(annotations are set just to demonstrate how the api should be configured):

{{{
package model
{
	import com.googlecode.flexxb.IIdentifiable;

	[XmlClass(alias="Person")]
	[ConstructorArg(reference="firstName")]
	[ConstructorArg(reference="lastName")]
	[Bindable]
	public class Person implements IIdentifiable
	{
		[XmlElement(alias="ID")]
		public var id : String = "1";
		[XmlAttribute(alias="FirstName")]
		public var firstName : String;
		[XmlAttribute(alias="LastName")]
		public var lastName : String;
		[XmlAttribute(alias="Age")]
		public var age : int;
		[XmlElement(alias="Position")]
		public var position : String;
		
		public function Person(firstName : String, lastName : String)
		{
			super();
			this.firstName = firstName;
			this.lastName = lastName;
		}
		
		public function get thisType():Class
		{
			return Person;
		}		
	}
}
}}}

Building the api descriptor should loomk like:

{{{
        var apiClass : FxClass = new FxClass(Person, "Person");				
        //Add class members descriptors
	apiClass.addElement("id", String, AccessorType.READ_WRITE, "ID");
	apiClass.addAttribute("firstName", String, AccessorType.READ_WRITE, "FirstName");
	apiClass.addAttribute("lastName", String, AccessorType.READ_WRITE, "LastName");
	apiClass.addAttribute("age", String, AccessorType.READ_WRITE, "Age");
	apiClass.addElement("position", String, AccessorType.READ_WRITE, "Position");
	//Set the constructor arguments, if any
	apiClass.addArgument("firstName");
	apiClass.addArgument("lastName");
	//Register the api descriptor class in the FlexXB engine
	FlexXBEngine.instance.api.processTypeDescriptor(apiClass);
}}}

Another example: let's assume we now have a department class (annotations are set just to demonstrate how the api should be configured):

{{{
package model
{
	import com.googlecode.flexxb.IIdentifiable;
	
	[XmlClass(alias="CompanyDepartment", prefix="dept", uri="http://myCompanyUrl.com")]
	[ConstructorArg(reference="id")]
	[ConstructorArg(reference="name")]
	[Bindable]
	public class Department implements IIdentifiable
	{
		[XmlAttribute(alias="ID")]
		public var id : String;
		
		[XmlElement(alias="DepartmentName")]
		public var name : String;
		
		[XmlElement(alias="Leader")]
		public var departmentHead : Person;
		
		public function Department(id : String, name : String)
		{
			super();
			this.id = id;
			this.name = name;
		}
		
		public function get thisType():Class
		{
			return Department;
		}
		
	}
}
}}}

The api descriptor is built like:

{{{
        var apiClass : FxClass = new FxClass(Department);
	apiClass.alias = "CompanyDepartment";
	apiClass.nameSpace = new Namespace("dept", "http://myCompanyUrl.com");
	//Add clas members descriptors
	apiClass.addAttribute("id", String, AccessorType.READ_WRITE, "ID");
	apiClass.addElement("name", String, AccessorType.READ_WRITE, "DepartmentName");
	apiClass.addElement("departmentHead", Person, AccessorType.READ_WRITE, "Leader");
	//Set the constructor arguments, if any
	apiClass.addArgument("id");
	apiClass.addArgument("name");
	//Register the api descriptor class in the FlexXB engine
	FlexXBEngine.instance.api.processTypeDescriptor(apiClass);
}}}