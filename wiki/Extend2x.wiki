#summary Customizing and extending FlexXB 2.x
#labels Phase-Implementation

FlexXB offers several extension points: 
 * Implement specialised interfaces in your model objects to modify the engine's behavior on serialization/deserialization;
 * Create a custom serialization context in order to define a new format for serializing (JSON, binary, etc.)
 * Create a custom serializer;
 * Create a custom annotation along with its own serializer;
 * Create custom classes for your annotations to be used in the Annotation API to markup classes without having to manually specify metadatas in the source code.

=Modifier interfaces=

There are four main interfaces objects can implement in order to impose a specific behavior of the engine: ISerializable, ISerializeNotifiable, IDeserializeNotifiable and ICycleRecoverable. All these interfaces are located in the com.googlecode.flexxb.interfaces.

=== 1. {{{com.googlecode.flexxb.interfaces.ISerializable}}} ===

You use this interface if your object requires the serialization/deserialization process be handled in a customized manner. This way the object itself will handle its own parsing/rendering.

{{{
/**           
* Interface for an object that requires custom serialization/deserialization into/from           
* a serialization format (XML, JSON, AMF etc.). Use this interface to instruct the engine            
* to delegate the serialization/deserialization task to the object itself.            
* @author aciobanu           
*           
*           
*/          
public interface ISerializable extends IIdentifiable {
{
       /**        
        * Serialize current object into a serialization format 
        */
        function serialize() : Object; 
       /**          
        * Deserialize this object from its serialized representation.            
        * @param source serialized data source          
        */      
        function deserialize(source : Object) : Object;
       /**         
        * Extract the object's identifier from the serialized source if                   
        * such an identifier exists.     
        * @param source serialized data source         
        * @return string representing object's identifier         
        *         
        */           
        function getIdValue(source : Object) : String;          
}   
}}}
The {{{getIdValue}}} method is used in case your object is identifiable by an id, and allows the extraction of the id value that is used in case you have object caching enabled. With the obtained id, the engine can look into the cache for an instance associated to that id and get that instance instead of creating a new object.

=== 2. {{{com.googlecode.flexxb.interfaces.ISerializeNotifiable}}} ===

Implementing this interfaces allows the object to get notified of the stages in which the serialization process is: Pre-serialize and post-serialize. The FlexXB Engine's default behavior is to dispatch pre/post serialize events as they occur for each object processed. When it encounters an ISerializeNotifiable object, it will call its {{{onPreSerialize}}} and {{{onPostSerialize}}} methods, overriding the default behavior.

{{{
/**
 * Optional interface to be implemented by objects which need specific
 * notification on the serialization process.<br> 
 * If the current object to be serialized implements this interface, the
 * engine will call the methods implemented on each process step (pre and 
 * post serialize) instead of firing an XmlEvent on the engine instance for
 * each step. <br>
 * Implementing this interface overrides the normal event dispatching in the 
 * engine.   
 * @author Alexutz
 * 
 */	
public interface ISerializeNotifiable
{
	/**
	 * Called before the serialization process of the current object begins.
	 * @param parent
	 * @param serializedData
	 * 
	 */				
	function onPreSerialize(parent : Object, serializedData : Object) : void;
	/**
	 * Called after the serialization process of the current object ends.
	 * @param parent
	 * @param serializedData
	 *  
	 */		
	function onPostSerialize(parent : Object, serializedData : Object) : void;
}
}}}

=== 3. {{{com.googlecode.flexxb.interfaces.IDeserializeNotifiable }}} ===

Implementing this interfaces allows the object to get notified of the stages in which the deserialization process is: Pre-deserialize and post-deserialize. The FlexXB Engine's default behavior is to dispatch pre/post deserialize events as they occur for each object processed. When it encounters an IDeserializeNotifiable object, it will call its {{{onPreDeserialize}}} and {{{onPostDeserialize}}} methods, overriding the default behavior.
{{{
/**
 * Optional interface to be implemented by objects which need specific
 * notification on the deserialization process.<br> 
 * If the current object to be serialized implements this interface, the
 * engine will call the methods implemented on each process step (pre and 
 * post deserialize) instead of firing an XmlEvent on the engine instance for
 * each step. <br>
 * Implementing this interface overrides the normal event dispatching in the 
 * engine.   
 * @author Alexutz
 * 
 */	
public interface IDeserializeNotifiable
{
	/**
	 * Called before the deserialization process of the current object begins.
	 * @param parent
	 * @param serializedData
	 * 
	 */		
	function onPreDeserialize(parent : Object, serializedData : Object) : void;
	/**
	 * Called after the deserialization process of the current object ends.
	 * @param parent
	 * @param serializedData
	 * 
	 */	
	function onPostDeserialize(parent : Object, serializedData : Object) : void;
}
}}}

=== 4. {{{com.googlecode.flexxb.interfaces.ICycleRecoverable}}} ===

FlexXB is able to detect and handle object cycles that would otherwise make it go into an infinite loop. One can implement this interface to instruct the engine to turn to the current object causing the cycle and ask it to provide a replacement for itself, one that would break the cycle.
{{{
/**
 * Optional interface that can be implemented by FlexXB bound objects to handle 
 * cycles in the object graph.
 * <p/>Normally a cycle in the object graph causes the engine to throw an error.
 * This is not always a desired behavior.Implementing this interface allows the 
 * user application to change this behavior.
 * 
 * @author Alexutz
 * 
 */	
public interface ICycleRecoverable
{
	/**
	 * Called when a cycle is detected by the engine to nominate a new
	 * object to be serialized instead.
	 * @param parentCaller reference to the parent object referencing the current ne 
	 * @return the object to be serialized instead of <code>this</code> or null to 
	 * instruct the engine to behave as if the object does not implement this interface. 
	 * 
	 */			
	function onCycleDetected(parentCaller : Object) : Object;
}
}}}

=Custom serialization contexts=

You use a custom serialization context (or a description context as it is refered to in the code) when you need to instruct FlexXB on how to handle a new format of serialized data (JSON, binary). By default, FlexXB has no idea how to write and read the serialized form, xml included. The xml serialization is done by making a custom serialization context. Serialization contexts allow you to:
 * define your annotations and serializers, converters;
 * get notified when a type has been described by FlexXB, and perform additional logic on the processed data;
 * provide specific logic for determining at runtime the type of the object to be used in deserialization by inspecting the serialized data source - because there are differentways of doing this in different formats (for example, in XML, one can do this by inspecting the tag name of the current element or the namespace in which it is defined).

_Note: The context is passed onto the annotation serializer instances so you can add here any specific method that will aid you in the de/serialization process._

The base class is {{{com.googlecode.flexxb.core.DescriptionContext}}} and there are 3 methods of interest:
 * {{{protected function performInitialization() : void}}} - do you registrations here
 * {{{public function getIncomingType(source : Object) : Class}}} - if required, add your type detection code here
 * {{{public function handleDescriptors(descriptors : Array) : void}}} - if required, perform additional actions on the descriptors(list of IClassAnnotation items) to aid in serialization.

Once created, one may register the description context with a {{{com.googlecode.flexxb.core.FxBEngine}}} instance by using the method registerDescriptionContext<br/>{{{public function registerDescriptionContext(name : String, context : DescriptionContext) : void}}}

As an example, let's take a look at some of the code for the Xml description context for FlexXB. We'll the the four elements being used: initializing the context by registering annotations and serializers, implementing the incomingType detector, handling newly processed descriptors and adding helper functions for teh annotations serializers:

{{{
public final class XmlDescriptionContext extends DescriptionContext
{
	private var classNamespaceMap : Dictionary;
		
	public function XmlDescriptionContext(){
		super();
		_configuration = new XmlConfiguration();
	}
	
	protected override function performInitialization() : void{
		registerSimpleTypeConverter(new ClassTypeConverter());
		registerSimpleTypeConverter(new XmlConverter());
		registerAnnotation(XmlAttribute.ANNOTATION_NAME, XmlAttribute, XmlAttributeSerializer);
		registerAnnotation(XmlElement.ANNOTATION_NAME, XmlElement, XmlElementSerializer);
		registerAnnotation(XmlArray.ANNOTATION_NAME, XmlArray, XmlArraySerializer);
		registerAnnotation(XmlClass.ANNOTATION_NAME, XmlClass, XmlClassSerializer);
		registerAnnotation(XmlConstants.ANNOTATION_NAMESPACE, XmlNamespace, null);
		setApiClasses(XmlApiClass, XmlApiArray, XmlApiAttribute, XmlApiElement, XmlApiNamespace);
	}
		
	public override function handleDescriptors(descriptors : Array) : void {
		for each(var classDescriptor : XmlClass in descriptors){
			//if the class descriptor defines a namespace, register it in the namespace map
			if (classDescriptor.nameSpace) {
				if (!classNamespaceMap) {
					classNamespaceMap = new Dictionary();
				}
				classNamespaceMap[classDescriptor.nameSpace.uri] = classDescriptor.type;
			}
		}
	}

	public function getXmlName(object : Object, version : String = "") : QName {
		if (object != null) {
			var classDescriptor : XmlClass = descriptorStore.getDescriptor(object, version) as XmlClass;
			if (classDescriptor) {
				return classDescriptor.xmlName;
			}
		}
		return null;
	}

	public function getClassByNamespace(ns : String) : Class {
		if (classNamespaceMap) {
			return classNamespaceMap[ns] as Class;
		}
		return null;
	}		
		
	public override function getIncomingType(source : Object) : Class {
		var incomingXML : XML = source as XML;
		if (incomingXML) {
			if (XmlConfiguration(configuration).getResponseTypeByTagName) {
				var tagName : QName = incomingXML.name() as QName;
				if (tagName) {
					var clasz : Class = getClassByAlias(tagName.localName);
					if (clasz) {
						return clasz;
					}
				}
			}
			if (XmlConfiguration(configuration).getResponseTypeByNamespace) {
				if (incomingXML.namespaceDeclarations().length > 0) {
					var _namespace : String = incomingXML.namespaceDeclarations()[0] as Namespace).uri;
					return getClassByNamespace(_namespace);
				}
			}
		}
		return null;
	}
}
}}}

= Custom annotations=

TODO

=Custom serializers=

TODO

=Custom annotation API=

TODO